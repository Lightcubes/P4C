/*
 *===========================================================================================
 * name          : p4c.c
 * Author        : Ying He
 * Version       :
 * Copyright     :
 * Description   :
 *
 * Highlights of implementation:
 * 1. Random number generator
 * 2. Producer can write [1:50], which is block write
 * 3. Consumer can read [0:64], which is unblock read
 * 4. Consumer need generate a file for logging data, use aio to write file in Consumer thread
 * 5. to keep the implementation simple, all code been put into one file p4c.c
 *
 * reversion history(include header file/Makefile/Document):
 * Oct-3-2016. install system and finish draft version
 * Oct-4-2016. implement & test Producer & Consumer
 * Oct-5-2016. add the aio file operations
 *             add the cons_b buffer to store data for aio to improve performance 
 *             use the CONS_BUFF_SIZE/2 as threshold to trigger aio_write
 * Oct-6-2016. Implement test Module
 *             formalized Makefile
 *             Split Source code and Header file
 *             formulated source code
 * Oct-7-2016. Stress testing and refine (./auto_test_script)
 *	       Performance testing and refine (please refer to linux_applayertest_summary_report.pdf)
 *	       Document (./linux_applayertest_summary_report.pdf)
 *	       Submit :)
 *=========================================================================================== 
 */

#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <aio.h>
#include <p4c.h>

/*
 *------------------------------------------------------------------------------------------- 
 * Global var section 
 *-------------------------------------------------------------------------------------------
 */

/*
 * file descriptor for saving log data
 */
size_t fd;

/*
 * Aysnchornous I/O control block 
 */
struct aiocb aiocb;

/*
 * time value to help to get random seed
 * and performance test
 */
struct timeval tpstart, tpend;
ssize_t time_use = 0;

/*
 * test buffer only can be used in debug/test version
 * to reopen and get data from log file for verification
 * in release version, memory do not allocated
 */
uint8_t * testbuffer;

/*
 * ideal file size, how may chars generated by producer in total
 */
size_t testbuffercounter;

/*
 * buffer for producer, defined in p4c.h
 */
producer_buff_t prod_b;

/*
 * buffer for consumer, defined in p4c.h
 */
consumer_buff_t cons_b;

/* 
 * buffer not full condition
 * happens when whatever data read from pro_d by consumer
 * producer on this condition will check if the
 * space is enough for write
 * if enough, execute write
 * if no enough, wait for next Buffer_Not_Full condition
 */
pthread_cond_t Buffer_Not_Full=PTHREAD_COND_INITIALIZER;

/* 
 * buffer not Empty condition
 * happens when whatever data write into pro_d by producer
 * consumer on this condition will execute read
 */
pthread_cond_t Buffer_Not_Empty=PTHREAD_COND_INITIALIZER;

/* 
 * Lock for critical section 
 */
pthread_mutex_t gLock=PTHREAD_MUTEX_INITIALIZER;

/*
 *------------------------------------------------------------------------------------------- 
 * Source code section 
 *-------------------------------------------------------------------------------------------
 */

/*
 * Function to check the aio status
 * if error happens, program will exit
 */
void Check_aio_status()
{
    size_t err = aio_error(&aiocb);
    size_t ret = aio_return(&aiocb);

    if (err != 0) {
        printf ("[%s] Error at aio_error() : %s\n", __func__, strerror (err));
	free(testbuffer);
        close(fd);
        exit(2);
    }

    if (!ret) {
	printf("[%s] Error at aio_return()\n", __func__);
	free(testbuffer);
	close(fd);
	exit(2);
    }
}

/*
 * Producer thread create random number of random char
 * if the buffer is not enough, wait for enough buffer
 */
void *Producer()
{
    size_t ran_w;
    size_t i;
    uint8_t temp_buff[PROD_BUFF_SIZE];
      
    for(;;)
    {
      /*
       * for scheduling
       */ 
      usleep(PRODUCT_SPEED);

      /*
       * CRITICAL SECTION START
       */
      pthread_mutex_lock(&gLock);

      /*
       *generate data
       */
      ran_w = 1 + (size_t)(MAX_WRITE*rand()/(RAND_MAX+1.0));

      for (i = 0; i < ran_w; i++){
          temp_buff[i] = CHAR_START+(uint8_t)((float)(CHAR_END-CHAR_START)*rand()/(RAND_MAX+1.0));
      }

#ifdef _DEBUG
      temp_buff[ran_w]='\0';
      printf("[%s] generate data: %lu bytes as : %s\n", __func__, ran_w, temp_buff);
#endif
      /*
       * Block producer thread and wait for enough space in Producer buffer
       */
      while (ran_w > (PROD_BUFF_SIZE-prod_b.counter)){
#ifdef _DEBUG
	printf("!!!!!!!!!!!!! Important Message,[%s] suspend!!!!!!!!!!\n", __func__);
	fflush(stdout);
#endif
	pthread_cond_wait(&Buffer_Not_Full, &gLock);
      }

      /*
       * check the file buffer flag
       * if Consumer thread sets it , means file buffer full
       * Producer thread need exit
       * check this after Producer resume since consumer may change the vaule
       */
      if (cons_b.filefull == TRUE){
#ifdef _DEBUG
	printf("[%s] exit, file buff full.\n", __func__);
	fflush(stdout);
#endif
	pthread_mutex_unlock(&gLock);
	pthread_exit("PRO_EXIT");
      }
      
      /*
       * Copy data from local buffer to Producer buffer
       * and testbuffer (in test/debug version)
       */
      for (i = 0; i < ran_w; ++i){
	  prod_b.pdata[(prod_b.end+i)%PROD_BUFF_SIZE] = temp_buff[i];
#ifdef _DEBUG
          testbuffer[testbuffercounter+i] = temp_buff[i];
#endif
      }
      prod_b.end = (prod_b.end+ran_w)%PROD_BUFF_SIZE;
      prod_b.counter += ran_w;
      testbuffercounter += ran_w;
#ifdef _DEBUG
      printf ("[%s] writes: begin=%lu, end=%lu, counter=%lu:\n", \
	      __func__, prod_b.begin, prod_b.end, prod_b.counter);
      for (i=0; i<prod_b.counter; ++i)
	printf("%c", prod_b.pdata[(prod_b.begin+i)%PROD_BUFF_SIZE]);
      printf ("\n");
#endif
      /*
       * CRITICAL SECTION END
       */      
      pthread_mutex_unlock(&gLock);
      pthread_cond_signal(&Buffer_Not_Empty);	
    }    
}

/*
 * Comsumer thread read and remove random number of chars from 
 * shared buffer, and put it into disk log file
 * an addtional file buffer used to support AIO write to improve 
 * performance
 */
void *Consumer()
{
    size_t ran_r;
    size_t i;
    static size_t aio_flag = 0;
    
    for(;;)
    {
      usleep(CONSUM_SPEED);

      /*
       * CRITICAL SCTION START
       */
      pthread_mutex_lock(&gLock);

      /*
       * AIO section
       */
      if (cons_b.counter > (size_t)(CONS_BUFF_SIZE)/2){
	  /*
	   * only can write when aio is idle
	   */
	  if (aio_error(&aiocb) != EINPROGRESS){
	    	/*
		 * not the first time, check the status of previous write operation
		 */
	    	if (aio_flag)Check_aio_status();

	 	if (cons_b.data_p >= (size_t)(CONS_BUFF_SIZE/2)){
	   		aiocb.aio_buf = cons_b.cdata;
	   		cons_b.aio_p = (size_t)(CONS_BUFF_SIZE/2);
	 	}
	 	else{
	   		aiocb.aio_buf = cons_b.cdata + (size_t)(CONS_BUFF_SIZE/2);
	   		cons_b.aio_p = 0;
	 	}

	 aiocb.aio_nbytes = (size_t)(CONS_BUFF_SIZE/2);
	 cons_b.counter -= (size_t)(CONS_BUFF_SIZE/2);

	 #ifdef _DEBUG
	 printf("[AIO] normal write %lu bytes to disk\n",aiocb.aio_nbytes);
	 #endif
	 
 	 if (aio_write(&aiocb) == -1) {
	    printf("[%s] Error at aio_write(): %s\n", __func__, strerror(errno));
	    close(fd);
	    exit(2);
	  }	 

	  aio_flag = 1;
	}/*if (aio_error(&aiocb) != EINPROGRESS)*/
      }/*if (cons_b.counter > (int)(CONS_BUFF_SIZE))*/
	   
      /*
       * AIO section end
       */

      
      /*
       * even consumer can read 0 byte back
       * if the buffer is empty it shall sleep there to save CPU MIPS
       */
      if (!(prod_b.counter)){
#ifdef _DEBUG
	printf("!!!!!!!!!!!!! Important Message, [%s] suspend!!!!!!!!!! \n", __func__);
	fflush(stdout);
#endif
	pthread_cond_wait(&Buffer_Not_Empty, &gLock);
	}

      /* 
       * did not use following statement as producer 
       * ran_r = 1 + (int)(MAX_READ*rand()/(RAND_MAX+1.0));
       * since consumer can read 0 byte
       */
      ran_r = (size_t)(MAX_READ*rand()/(RAND_MAX+1.0));
      ran_r = (ran_r<prod_b.counter)?ran_r:prod_b.counter;
      
      /*
       * put data into file buffer
       */
      for (i=0; i<ran_r; ++i){
	cons_b.cdata[(cons_b.data_p+i)%CONS_BUFF_SIZE] = \
	  prod_b.pdata[(prod_b.begin+i)%PROD_BUFF_SIZE];
	}

      prod_b.begin = (prod_b.begin+ran_r)%PROD_BUFF_SIZE;
      prod_b.counter -= ran_r;
      cons_b.data_p = (cons_b.data_p+ran_r)%CONS_BUFF_SIZE;
      cons_b.counter += ran_r;
      cons_b.file_len += ran_r;
#ifdef _DEBUG
      printf ("[%s] read %lu bytes: begin=%lu, end=%lu, counter=%lu:\n", \
	      __func__, ran_r, prod_b.begin, prod_b.end, prod_b.counter);
      
      for (i=0; i<prod_b.counter; ++i){
	printf("%c", prod_b.pdata[(prod_b.begin+i)%PROD_BUFF_SIZE]);
      }
      
      printf ("\n[%s] filelen =%lu, consCounter = %lu\n", __func__, cons_b.file_len, cons_b.counter);
#endif
      
      /* 
       * if the file buffer is full, prepare for exit thread
       * Consumer just set the flag in critical section
       * After quit critical section the pthread_exit() will be called
       * otherwise, the lock will get problem
       */
       if ((cons_b.file_len+MAX_WRITE)>LOG_FILE_SIZE){
	/*
	 * read all rest remainder chars in Producer buffer to file buffer
	 */
	for (i=0; i<prod_b.counter; ++i){
	  cons_b.cdata[(cons_b.data_p+i)%CONS_BUFF_SIZE] = \
	    prod_b.pdata[(prod_b.begin+i)%PROD_BUFF_SIZE];
	}

	cons_b.data_p = (cons_b.data_p+prod_b.counter)%CONS_BUFF_SIZE;
	cons_b.counter += prod_b.counter;
        cons_b.file_len += prod_b.counter;
	prod_b.begin = 0;
	prod_b.counter = 0;
	prod_b.end = 0;

	/*
	 * Data clean now, let's set the quit flag
	 * for both producer and consumer
	 */
	cons_b.filefull = TRUE;
#ifdef _DEBUG
	printf ("\n[%s @ exit] filelen =%lu, consCounter = %lu\n", __func__, cons_b.file_len, cons_b.counter);
#endif
      }

      /*
       * CRITICAL SECTION END
       */      
      pthread_mutex_unlock(&gLock);
      if (ran_r) pthread_cond_signal(&Buffer_Not_Full);

      /*
       * exit Consumer thread if file buffer full
       */
      if (cons_b.filefull == TRUE){

	/*
  	 * Write all data in cons_b into file
	 */
	while (aio_error(&aiocb) == EINPROGRESS);
	Check_aio_status();
	
	if (cons_b.counter){
	 	if (cons_b.data_p>cons_b.aio_p){
	    		aiocb.aio_buf = cons_b.cdata + cons_b.aio_p;
	    		aiocb.aio_nbytes = cons_b.counter;

	    #ifdef _DEBUG
	    printf("[AIO EXIT] write %lu bytes to disk\n", aiocb.aio_nbytes);
	    #endif
	 
	    		if (aio_write(&aiocb) == -1) {
	      		printf("[%s] Error at aio_write(): %s\n", __func__, strerror(errno));
	      		close(fd);
	      		exit(2);
	    	}

	    	while (aio_error(&aiocb) == EINPROGRESS);
		Check_aio_status();
	}
	else{
	    	aiocb.aio_buf = cons_b.cdata + cons_b.aio_p;
	    	aiocb.aio_nbytes = (size_t)(CONS_BUFF_SIZE/2);

	    #ifdef _DEBUG
	    printf("[AIO EXIT] 1/2 write %lu bytes to disk\n", aiocb.aio_nbytes);
	    #endif
	    
	    	if (aio_write(&aiocb) == -1) {
	      		printf("[%s] Error at aio_write(): %s\n", __func__, strerror(errno));
	      		close(fd);
	      		exit(2);
	    	}

	    	while (aio_error(&aiocb) == EINPROGRESS);
		Check_aio_status();

	    	/*
	     	 * data is more than CONS_BUFF_SIZE/2
	     	 */
	    	cons_b.counter -= (size_t)(CONS_BUFF_SIZE/2);
	    	cons_b.aio_p = (cons_b.aio_p+(size_t)(CONS_BUFF_SIZE/2))%CONS_BUFF_SIZE;
	    	aiocb.aio_buf = cons_b.cdata + cons_b.aio_p;
	    	aiocb.aio_nbytes = cons_b.counter;
	    
	    #ifdef _DEBUG
	    printf("[AIO EXIT] 2/2 write %lu bytes to disk\n", aiocb.aio_nbytes);
	    #endif
	    
	    	if (aio_write(&aiocb) == -1) {
	      		printf("[%s] Error at aio_write(): %s\n", __func__, strerror(errno));
	      		close(fd);
	      		exit(2);
	    	}
	    
	    while (aio_error(&aiocb) == EINPROGRESS);	  
	 } /*if (cons_b.data_p>cons_b.aio_p)*/
	} /*if (cons_b.counter)*/
#ifdef _DEBUG
      printf("\n[%s] exit, file buff full.\n", __func__);
      fflush(stdout);
#endif
	pthread_exit("CON_EXIT");
      }/*if (cons_b.filefull == TRUE)*/
    } /*for(;;)*/   
}

int main()
{    
    pthread_t ptid,ctid;
    size_t res;

    /*
     *Global var init
     */

    /*
     * file descriptor
     * O_CREAT create file
     * O_RDWR  RW for test, the requirement only need W
     * O_TRUNC if file exist, trunc the length to 0
     * O_APPEND append form tail of the file when write
     */ 
    fd = open(DATALOGFILE, O_CREAT | O_RDWR | O_TRUNC | O_APPEND, S_IRUSR | S_IWUSR);
    if (fd == -1) {
      printf("[%s] Error at open(): %s\n", __func__, strerror(errno));
      exit(1);
    }

    /*
     * asynchronous IO control block
     */
    memset(&aiocb, 0, sizeof(struct aiocb));
    aiocb.aio_fildes = fd;
    
    /*
     * Producer buffer
     */
    prod_b.begin = 0;
    prod_b.end = 0;
    prod_b.counter = 0;
    memset(prod_b.pdata,'\0',PROD_BUFF_SIZE);
    
    /*
     * Consumer buffer
     */
    cons_b.data_p = 0;
    cons_b.filefull = FALSE;
    cons_b.aio_p = 0;
    cons_b.file_len = 0;
    cons_b.aio_p = 0;
    memset(cons_b.cdata,'\0',CONS_BUFF_SIZE);

    /*
     * init random seed
     */
    gettimeofday(&tpstart, NULL);
    srand(tpstart.tv_usec);

    /*
     * test buffer
     */
#ifdef _DEBUG
     testbuffer = malloc(sizeof(char) * LOG_FILE_SIZE);
#endif
     testbuffercounter = 0;

    /*
     *create producer and consumer threads
     */
    res = pthread_create(&ptid,NULL,Producer,NULL);
    if (res){
      printf("Cannot create producer thread with exit(%lu)\n", res);
      return (res);
    }
	    
    res = pthread_create(&ctid,NULL,Consumer,NULL);
    if (res){
      printf("Cannot create comsumer  thread with exit(%lu)\n", res);
      return (res);
    }
   
#ifdef _DEBUG
    printf("Both Producer & Consumer threads created\n");
#endif       

    pthread_join(ptid,NULL);
    pthread_join(ctid,NULL);

#ifdef _DEBUG
    printf("Both Producer & Consumer threads exited\n");
#endif        

    close (fd);

#ifdef _DEBUG
    /*
     * Test section
     */
    size_t i;
    ssize_t ret;
    
    fd = open(DATALOGFILE, O_RDONLY);
    if (fd == -1) {
      printf("[%s] Error at open(): %s\n", __func__, strerror(errno));
      exit(1);
    }

    char * filereadbuff = malloc(sizeof(char) * LOG_FILE_SIZE);

    ret = read (fd, filereadbuff, testbuffercounter);

    if (ret!= testbuffercounter){
	printf ("[%s] test fail, file size error, file (%lu), producer generated (%lu)", \
		__func__, ret, testbuffercounter);
        close (fd);
	free(filereadbuff);
	free(testbuffer);
	exit(1);
    }

    for (i=0; i<testbuffercounter; ++i){
	//printf("%c",testbuffer[i]);
	if (testbuffer[i] != filereadbuff[i]) break;
    }

    if (i == testbuffercounter)printf ("\nTest Passed\n");
	else printf ("\nTest Fail\n");

    close (fd);
    free(filereadbuff);
    free(testbuffer);
#endif

    
    printf("%lu bytes wrote into %s", testbuffercounter, DATALOGFILE);

    gettimeofday(&tpend, NULL);
    time_use = (tpend.tv_sec-tpstart.tv_sec)*1000000 +\
    	(tpend.tv_usec - tpstart.tv_usec);
    printf("time used: %20ld u-seconds\n", time_use);
    
    return 0;
}
